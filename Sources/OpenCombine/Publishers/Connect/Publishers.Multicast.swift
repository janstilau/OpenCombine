// MultiCast 其实是将上游的信号源, 变为 Dispatch 信号源的一个机制.\
// 一般不会直接使用 multicast, share, 和 makeConnectable 里面会用到. 
extension Publisher {
    /// Applies a closure to create a subject that delivers elements to subscribers.
    // 真正的能够成为多路复用的响应链, 是因为将后面的链条, 都挂钩到了一个 Subject 对象上了.
    // Subject 天然就带有分发的机制, Multicast 也就利用了这个机制. 
    
    /// Use a multicast publisher when you have multiple downstream subscribers, but you
    /// want upstream publishers to only process one `receive(_:)` call per event.
    /// This is useful when upstream publishers are doing expensive work you don’t want
    /// to duplicate, like performing network requests.
    
    /// The following example uses a sequence publisher as a counter to publish three
    /// random numbers, generated by a `map(_:)` operator.
    /// It uses a `multicast(_:)` operator whose closure creates a `PassthroughSubject`
    /// to share the same random number to each of two subscribers. Because the multicast
    /// publisher is a `ConnectablePublisher`, publishing only begins after a call to
    /// `connect()`.
    ///
    ///     let pub = ["First", "Second", "Third"].publisher
    ///         .map( { return ($0, Int.random(in: 0...100)) } )
    ///         .print("Random")
    ///         .multicast { PassthroughSubject<(String, Int), Never>() }
    ///
    ///     cancellable1 = pub
    ///        .sink { print ("Stream 1 received: \($0)")}
    ///     cancellable2 = pub
    ///        .sink { print ("Stream 2 received: \($0)")}
    
    ///     pub.connect()
    
    ///     // Prints:
    ///     // Random: receive value: (("First", 9))
    ///     // Stream 2 received: ("First", 9)
    ///     // Stream 1 received: ("First", 9)
    ///     // Random: receive value: (("Second", 46))
    ///     // Stream 2 received: ("Second", 46)
    ///     // Stream 1 received: ("Second", 46)
    ///     // Random: receive value: (("Third", 26))
    ///     // Stream 2 received: ("Third", 26)
    ///     // Stream 1 received: ("Third", 26)
    
    /// In this example, the output shows that the `print(_:to:)` operator receives each
    /// random value only one time, and then sends the value to both subscribers.
    ///
    /// - Parameter createSubject: A closure to create a new `Subject` each time
    ///   a subscriber attaches to the multicast publisher.
    public func multicast<SubjectType: Subject>(
        _ createSubject: @escaping () -> SubjectType
    ) -> Publishers.Multicast<Self, SubjectType>
    where Failure == SubjectType.Failure, Output == SubjectType.Output
    {
        return Publishers.Multicast(upstream: self, createSubject: createSubject)
    }
    
    // 闭包的这种方式, 提供了更多的可操作性.
    // 如果提供了 Subject, 可以直接纳入到 闭包 的方式中.
    public func multicast<SubjectType: Subject>(
        subject: SubjectType
    ) -> Publishers.Multicast<Self, SubjectType>
    where Failure == SubjectType.Failure, Output == SubjectType.Output
    {
        return multicast { subject }
    }
}


extension Publishers {
    // Subject, 天然就是一个多路分发器, 所以在实现 Multicast 语义的 Publisher 的时候, 就是使用了 Subject
    public final class Multicast<Upstream: Publisher, SubjectType: Subject>
    : ConnectablePublisher
    where Upstream.Failure == SubjectType.Failure,
          Upstream.Output == SubjectType.Output
    {
        // 显式地进行类型的 typealiase, 要比通过参数进行类型确认要清晰的多.
        public typealias Output = Upstream.Output
        public typealias Failure = Upstream.Failure
        
        /// The publisher that this publisher receives elements from.
        public let upstream: Upstream
        
        /// A closure to create a new Subject each time a subscriber attaches
        /// to the multicast publisher.
        // 如何去创建分发节点, 是用 Object 这个天然就是可以分发的类型
        public let createSubject: () -> SubjectType
        
        private let lock = UnfairLock.allocate()
        
        private var generatedSubject: SubjectType?
        
        // 这里直接使用 lazy 什么问题吗
        // 不过, 这里倒是展示了 lazy 的实现方式.
        private var lazySubject: SubjectType {
            lock.lock()
            if let subject = generatedSubject {
                lock.unlock()
                return subject
            }
            
            let subject = createSubject()
            self.generatedSubject = subject
            lock.unlock()
            return subject
        }
        
        /// Creates a multicast publisher that applies a closure to create a subject that
        /// delivers elements to subscribers.
        ///
        /// - Parameter createSubject: A closure that returns a `Subject` each time
        ///   a subscriber attaches to the multicast publisher.
        // 对于 Publihser 来说, 在类内的主要逻辑, 就是收集数据.
        public init(upstream: Upstream, createSubject: @escaping () -> SubjectType) {
            self.upstream = upstream
            self.createSubject = createSubject
        }
        
        deinit {
            lock.deallocate()
        }
        
        /*
         核心所在. Subscriber 都附加到了 Subject 上.
         Connect 则是将 subject 作为 subscriber 附加到 Upstream 上.
         */
        // 当, 后方节点要 Attach 的时候, 生成 Inner 节点, attach 到 Subject 对象上.
        public func receive<Downstream: Subscriber>(subscriber: Downstream)
        where SubjectType.Failure == Downstream.Failure,
              SubjectType.Output == Downstream.Input
        {
            lazySubject.subscribe(Inner(parent: self, downstream: subscriber))
        }
        
        // 后续的节点, 都 Attach 到 Subject 上.
        // 前方的节点, 一直不进行真正的 subscribe 操作, 直到 connect 的时候, 才真正的完成线路的搭建.
        public func connect() -> Cancellable {
            // 返回 SubjectSubscriber. 它的 cancel, 会阻断上游节点和 subject 的通路. 
            return upstream.subscribe(lazySubject)
        }
    }
}

extension Publishers.Multicast {
    // 直接将 subscriber 放到 Subject 上有什么问题.
    private final class Inner<Downstream: Subscriber>
    : Subscriber,
      Subscription,
      CustomStringConvertible,
      CustomReflectable,
      CustomPlaygroundDisplayConvertible
    where Upstream.Output == Downstream.Input, Upstream.Failure == Downstream.Failure
    {
        typealias Input = Upstream.Output
        typealias Failure = Upstream.Failure
        
        private enum State {
            case ready(upstream: Upstream,
                       downstream: Downstream)
            case subscribed(upstream: Upstream,
                            downstream: Downstream,
                            subjectSubscription: Subscription)
            case terminal
        }
        
        private let lock = UnfairLock.allocate()
        
        private var state: State
        
        fileprivate init(parent: Publishers.Multicast<Upstream, SubjectType>,
                         downstream: Downstream) {
            state = .ready(upstream: parent.upstream, downstream: downstream)
        }
        
        deinit {
            lock.deallocate()
        }
        
        // 这个 Subscription, 是 Subejct.Conduit 对象.
        func receive(subscription: Subscription) {
            lock.lock()
            guard case let .ready(upstream, downstream) = state else {
                lock.unlock()
                subscription.cancel()
                return
            }
            state = .subscribed(upstream: upstream,
                                downstream: downstream,
                                subjectSubscription: subscription)
            lock.unlock()
            downstream.receive(subscription: self)
        }
        
        func receive(_ input: Input) -> Subscribers.Demand {
            lock.lock()
            guard case let .subscribed(_, downstream, subjectSubscription) = state else {
                lock.unlock()
                return .none
            }
            lock.unlock()
            // 这里进行的 demand 管理, 是 Subject 的 Conduit 的 demand 管理.
            let newDemand = downstream.receive(input)
            if newDemand > 0 {
                subjectSubscription.request(newDemand)
            }
            return .none
        }
        
        func receive(completion: Subscribers.Completion<Failure>) {
            lock.lock()
            guard case let .subscribed(_, downstream, _) = state else {
                lock.unlock()
                return
            }
            state = .terminal
            lock.unlock()
            downstream.receive(completion: completion)
        }
        
        func request(_ demand: Subscribers.Demand) {
            lock.lock()
            guard case let .subscribed(_, _, subjectSubscription) = state else {
                lock.unlock()
                return
            }
            lock.unlock()
            // 这里的 subjectSubscription 是 Subject 里面的 Conduit 对象.
            // 所以实际上, Demand 管理, 其实是到了 Subject 这一层就结束了.
            subjectSubscription.request(demand)
        }
        
        func cancel() {
            lock.lock()
            guard case let .subscribed(_, _, subjectSubscription) = state else {
                lock.unlock()
                return
            }
            state = .terminal
            lock.unlock()
            // 将自己, 从 Subject 中进行删除.
            subjectSubscription.cancel()
        }
        
        
        
        
        fileprivate var description: String { return "Multicast" }
        
        fileprivate var customMirror: Mirror {
            return Mirror(self, children: EmptyCollection())
        }
        
        fileprivate var playgroundDescription: Any { return description }
    }
}
