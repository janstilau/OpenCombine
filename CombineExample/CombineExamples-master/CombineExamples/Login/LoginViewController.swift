//
//  ViewController.swift
//  CombineExamples
//
//  Created by Pawel Krawiec on 17/06/2019.
//  Copyright © 2019 tailec. All rights reserved.
//

import UIKit
import Combine

class LoginViewController: UIViewController {
    
    @IBOutlet weak private var usernameTextField: UITextField!
    @IBOutlet weak private var passwordTextField: UITextField!
    @IBOutlet weak private var loginButton: UIButton!
    @IBOutlet weak private var activityIndicator: UIActivityIndicatorView!
    
    // 实际上, 都使用 Subject 也是可以的. @Published 相当于是将这个过程, 隐藏到了自己的赋值语句中了.
    @Published private var username: String = ""
    @Published private var password: String = ""
    
    private let loginTaps = PassthroughSubject<Void, Never>()
    
    private let executing = CurrentValueSubject<Bool, Never>(false)
    
    private var cancellableBag = Set<AnyCancellable>()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        /*
         根据, 之前 Rx 里面的实现. CombineLatest 会在内部注册成为所监听的 Publisher 节点.
         然后在每次收到上游事件之后, 如果上游都已经 Publish 过了, 将存储的值组成成为一个 Tuple 对象, 然后发送给下游.
         */
        let credentials = Publishers.CombineLatest($username, $password)
        /*
         Summary

         Shares the output of an upstream publisher with multiple subscribers.
         Declaration

         func share() -> Publishers.Share<Self>
         Discussion

         The publisher returned by this operator supports multiple subscribers, all of whom receive unchanged elements and completion states from the upstream publisher.
         
         // 这里说的很清楚, Share 就是 MultiCast + Autoconnect
         Publishers.Share is effectively a combination of the Publishers.Multicast and PassthroughSubject publishers, with an implicit autoconnect().
         The following example uses a sequence publisher as a counter to publish three random numbers, generated by a map(_:) operator. It uses a share() operator to share the same random number to each of two subscribers. This example uses a delay(for:tolerance:scheduler:options:) operator only to prevent the first subscriber from exhausting the sequence publisher immediately; an asynchronous publisher wouldn’t need this.
         let pub = (1...3).publisher
             .delay(for: 1, scheduler: DispatchQueue.main)
             .map( { _ in return Int.random(in: 0...100) } )
             .print("Random")
             .share()

         cancellable1 = pub
             .sink { print ("Stream 1 received: \($0)")}
         cancellable2 = pub
             .sink { print ("Stream 2 received: \($0)")}

         // Prints:
         // Random: receive value: (20)
         // Stream 1 received: 20
         // Stream 2 received: 20
         // Random: receive value: (85)
         // Stream 1 received: 85
         // Stream 2 received: 85
         // Random: receive value: (98)
         // Stream 1 received: 98
         // Stream 2 received: 98
         Without the share() operator, stream 1 receives three random values, followed by stream 2 receiving three different random values.
         Also note that Publishers.Share is a class rather than a structure like most other publishers. This means you can use this operator to create a publisher instance that uses reference semantics.
         Returns

         A class instance that shares elements received from its upstream to multiple subscribers.

         */
            .share()
        
        credentials
            .map { uname, pass in
                // 将两个 String 值, 变化成为一个 Bool 变量 .
                return uname.count >= 4 && pass.count >= 4
            }
            .prepend(false) // initial state, 这是 Prepend, 可以让 UI 进行初始化.
            .assign(to: \.isEnabled, on: loginButton)
            .store(in: &cancellableBag)
        
        // 因为 credentials 在这里又被用到了, 所以 share 就有了意义.
        loginTaps
            .withLatestFrom(credentials)
            .handleEvents(receiveOutput: { [weak self] _ in
                guard let strongSelf = self else { return }
                //
                strongSelf.executing.send(true)
            })
        /*
         flatMapLatest, 相比较于 FlatMap, 其实是多了一个对于当前链路的存储过程.
         当触发了新的 Publisher 的生成的时候, 就对原有的 Publisher 链路进行 cancel.
         */
            .flatMapLatest { uname, pass in
                URLSession.shared.get(url: URL(string: "https://postman-echo.com/basic-auth")!,
                                      params: ["username": uname,
                                               "password": pass,
                                               "Authorization": "Basic cG9zdG1hbjpwYXNzd29yZA=="])
                    .retry(3)
                    .decode(type: AuthResponse.self, decoder: JSONDecoder())
                    .map { $0.authenticated }
                    .replaceError(with: false)
            }
            .handleEvents(receiveOutput: { [weak self] _ in
                guard let strongSelf = self else { return }
                strongSelf.executing.send(false)
            })
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher() // 这里 erase 有什么作用呢, 没有暴露给外界, 直接原来的类型就可以吧. 
            .sink(receiveValue: { [weak self] result in
                guard let strongSelf = self else { return }
                let alert = UIAlertController(title: result ? "Success!" : "Failure!", message: nil, preferredStyle: .alert)
                alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
                strongSelf.present(alert, animated: true)
            })
            .store(in: &cancellableBag)
        
        
        
        // executing 的改变, 是在上述的网络交互的过程中进行的改变.
        executing
            .map(!)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
            .assign(to: \.isHidden, on: activityIndicator)
            .store(in: &cancellableBag)
    }
    
    /*
     不太了解, 这是不是 Combine 的正常用法.
     @Published 中, 其实就是藏了一个 Subject 的对象. 所以, 这里其实都是用 Subject 这个对象, 来将响应式, 变化成为了响应式.
     */
    @IBAction func usernameDidChange(_ sender: UITextField) {
        username = sender.text ?? ""
    }
    
    @IBAction func passwordDidChange(_ sender: UITextField) {
        password = sender.text ?? ""
    }
    
    // 原有的 Target Action, 触发了 Subject 的改动. 而 Subject 下面, 进行了各种回调的注册.
    @IBAction func loginDidTap(_ sender: UIButton) {
        loginTaps.send()
    }
}

private struct AuthResponse: Decodable {
    let authenticated: Bool
}
